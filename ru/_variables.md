
# Переменные

Переменные являются сутью любого языка программирования. Они позволяют нам использовать значения без необходимости копировать их снова и снова. Самое главное, что они делают обновление этого значения очень легким. Не нужен поиска и ручная замена.

Однако CSS не что иное, как огромная корзина, содержащая все наши яйца. В отличие от многих языков, нет никаких реальных областей видимости в CSS. Из-за этого, мы должны уделять много внимания при добавлении переменных из-за риска конфликтов.

Мой совет создавать переменные, когда это имеет смысл. Не инициализировать новые переменные ради инциализации. Новая переменная должна быть создана только тогда, когда выполняются следующие критерии:

* это значение повторяется хотя бы дважды;
* это значение будет обновлено хотя бы один раз;
* все вхождения значения привязаны к переменной (т.е не по стечению обстоятельств).

В принципе, нет никакого смысла объявлять переменную, которая никогда не будет обновлена или которая используется только в одном месте.






## Контекст

Область видимости переменных в Sass изменялась за эти годы. До недавнего времени, объявленые переменные в пределах набора правил и других областей были локальными по умолчанию. Однако, когда была уже глобальная переменная с тем же именем, назначение локального значения изменило бы глобальную переменную. Начиная с версии 3.4, Sass теперь правильно решает концепцию областей видимости и создает новую локальную переменную вместо перезаписи глобальной.

Документация говорит о *затенение глобальной переменной*. При объявлении переменной, которая уже существует в глобальной области во внутренней области (селектор, функции, примесь ...), локальная переменная называется *тенью* глобальный. В основном, она перезаписывается только для локальной области видимости.

Следующий фрагмент кода объясняет концепцию *затенение переменных*.

<div class="code-block">
  <div class="code-block__wrapper" data-syntax="scss">
{% highlight scss %}
// Объявите глобальную переменную на корневом уровне.
// В этом случае используется флаг `!global`.
$variable: 'initial value' !global;

// Создайте примесь, которая перезаписывает глобальные переменные.
@mixin global-variable-overriding {
  $variable: 'mixin value' !global;
}

.local-scope::before {
  // Создайте локальную переменную, которая затеняет глобальную.
  $variable: 'local value';

  // Примените примесь: она перезапишет глобальную переменную.
  @include global-variable-overriding;

  // Выведите значение переменной.
  // Теперь значение **локальной**, с тех пор, как она затеняет глобальную.
  content: $variable;
}

// Выведите это переменную в другом селекторе, который не делает затенения.
// Теперь значение **глобальное**, как и ожидалось.
.other-local-scope::before {
  content: $variable;
}
{% endhighlight %}
  </div>
  <div class="code-block__wrapper" data-syntax="sass">
{% highlight sass %}
// Объявите глобальную переменную на корневом уровне.
// В этом случае используется флаг `!global`.
$variable: 'initial value' !global

// Создайте примесь, которая перезаписывает глобальные переменные.
@mixin global-variable-overriding
  $variable: 'mixin value' !global

.local-scope::before
  // Создайте локальную переменную, которая затеняет глобальную.
  $variable: 'local value'

  // Примените примесь: она перезапишет глобальную переменную.
  +global-variable-overriding

  // Выведите значение переменной.
  // Теперь значение **локальной**, с тех пор, как она затеняет глобальную.
  content: $variable

// Выведите это переменную в другом селекторе, который не делает затенения.
// Теперь значение **глобальное**, как и ожидалось.
.other-local-scope::before
  content: $variable
{% endhighlight %}
  </div>
</div>






## Флаг `!default`

При построении библиотеки, фреймворка, сетки или любого Sass кода, который предназначен для использования другими разработчиками, все переменные должны быть определены с флагом `!default`, чтобы они могли быть перезаписаны.

<div class="code-block">
  <div class="code-block__wrapper" data-syntax="scss">
{% highlight scss %}
$baseline: 1em !default;
{% endhighlight %}
  </div>
  <div class="code-block__wrapper" data-syntax="sass">
{% highlight sass %}
$baseline: 1em !default
{% endhighlight %}
  </div>
</div>

Благодаря этому, разработчик может определить свою собственную переменную `$baseline` *перед* импортом вашей библиотеки, при этом она не будет переопределена.

<div class="code-block">
  <div class="code-block__wrapper" data-syntax="scss">
{% highlight scss %}
// Переменная разработчика
$baseline: 2em;

// Объявление переменной `$baseline` из библиотеки
@import 'your-library';

// $baseline == 2em;
{% endhighlight %}
  </div>
  <div class="code-block__wrapper" data-syntax="sass">
{% highlight sass %}
// Переменная разработчика
$baseline: 2em

// Объявление переменной `$baseline` из библиотеки
@import your-library

// $baseline == 2em
{% endhighlight %}
  </div>
</div>






## Флаг `!global`

Флаг `!global` следует использовать только тогда, когда переопределяете глобальную переменнуюу из локальной области видимости. При определении переменной на корневом уровне, `global` флаг должен быть опущен.

<div class="code-block">
  <div class="code-block__wrapper" data-syntax="scss">
{% highlight scss %}
// Yep
$baseline: 2em;

// Nope
$baseline: 2em !global;
{% endhighlight %}
  </div>
  <div class="code-block__wrapper" data-syntax="sass">
{% highlight sass %}
// Yep
$baseline: 2em

// Nope
$baseline: 2em !global
{% endhighlight %}
  </div>
</div>






## Много переменных или карты

Существуют преимущества использования карт переменных, а не нескольких отдельных переменных. Главным является способность прохода по картам, которое невозможно с отдельными переменными.

Другая выгода, что при использование карт есть способность создать небольшой функции получения значений, чтобы обеспечить дружественный API. Например, рассмотрим следующий Sass код:

<div class="code-block">
  <div class="code-block__wrapper" data-syntax="scss">
{% highlight scss %}
/// Карта Z-indexe'ов, собирает все Z слои приложения
/// @access приватная
/// @type Карта
/// @prop {String} ключ - Имя слоя
/// @prop {Number} значение - Z значение соответствущие ключу
$z-indexes: (
  'modal': 5000,
  'dropdown': 4000,
  'default': 1,
  'below': -1,
);

/// Получения z-index значения из имени слоя
/// @access публичная
/// @param {String} $layer - Имя слоя
/// @return {Number}
/// @require $z-indexes
@function z($layer) {
  @return map-get($z-indexes, $layer);
}
{% endhighlight %}
  </div>
  <div class="code-block__wrapper" data-syntax="sass">
{% highlight sass %}
/// Карта Z-indexe'ов, собирает все Z слои приложения
/// @access приватная
/// @type Карта
/// @prop {String} ключ - Имя слоя
/// @prop {Number} значение - Z значение соответствущие ключу
$z-indexes: ('modal': 5000, 'dropdown': 4000, 'default': 1, 'below': -1,)

/// Получения z-index значения из имени слоя
/// @access приватная
/// @param {String} $layer - Имя слоя
/// @return {Number}
/// @require $z-indexes
@function z($layer)
  @return map-get($z-indexes, $layer)
{% endhighlight %}
  </div>
</div>
